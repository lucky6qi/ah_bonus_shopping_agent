## AH Shopping Agent：项目方向与整体逻辑总结

### 项目目标

- **核心目标**：做一个能“读懂需求、自己逛超市、帮你下单”的 AH.nl 智能购物代理。
- **范围**：围绕 AH.nl 生态，尤其是 **Bonus 打折区 + 历史购买记录 + 现有购物车**，自动完成“看折扣 → 选品 → 校验 → 加入购物车”的整条链路。

---

### 整体流程（从用户视角）

1. **用户给出购物需求**
   - 通过 CLI、`.txt` prompt、或浏览器扩展输入一段自然语言需求，例如：
   - “一周 2 个大人要吃的健康食材，必须有 2 盒 1L 牛奶、10 个鸡蛋、4 种肉、4 种菜、3 种水果，总价 > 50 欧。”

2. **系统获取可用商品池**
   - 抓取 `ah.nl/bonus` 当前所有打折商品。
   - 加载本地 `eerder_gekocht` 历史购买商品（相当于“个人常买数据库”）。
   - 将两部分合并成一个“候选商品全集”，后续所有智能决策都基于这个全集。

3. **AI 生成候选购物清单（按桶分类）**
   - 把“候选商品 + 用户需求 + 最近几次购物历史”一起丢给 LLM。
   - LLM 输出一个 **分桶的购物清单**：
     - essentials / meat / vegetables / fruit / snacks / beverages / other
   - 同时尊重 `Must-buy Items`：必须买的东西要在清单里出现并尽量匹配数量规格。

4. **读取当前购物车状态**
   - 打开 AH.nl，复用已有登录会话（不反复登录）。
   - 读取购物车总金额，如果为 0 则认为是“空车”，否则再抓取车内商品明细。

5. **LLM 校验“当前购物车 + 计划清单”是否满足需求**
   - 如果购物车是空的：直接按之前的清单往里加，不用再问 LLM。
   - 如果购物车不为空：
     - 把 **当前购物车商品 + 用户需求 + 全部候选商品** 发给 LLM。
     - 让 LLM 判断：
       - 需求是否已基本满足？
       - 还缺什么类别 / 具体商品？
       - 应该从“候选商品池”里再挑哪些具体货（带数量和理由）。
   - 得到一个“建议需要额外添加的具体商品列表”。

6. **自动往购物车里加商品**
   - 对于需要添加的每个商品：
     - 在 AH 页面上搜索 / 定位该商品卡片。
     - 尝试点击加购按钮（处理弹窗、loading、结构变化等现实问题）。
   - 最终状态：购物车中应该尽可能满足用户的自然语言约束（数量、种类、价格区间等）。

7. **收尾与通知**
   - 手动模式：浏览器保持打开，让用户自己去付款。
   - 自动模式：
     - 自动关闭浏览器。
     - 向预设邮箱发一封“购物车已准备好，请去付款”的通知邮件。

---

### 关键设计理念（重写时最值得保留的部分）

- **1. 一切围绕“用户自然语言需求”展开**
  - 项目不是在做“爬虫 + 自动点按钮”，而是在做一个“**能理解生活需求 → 转化为购物决策**”的代理。
  - 自然语言需求是整个 pipeline 的起点，后面所有模块都服务于“满足这段话”。

- **2. 商品池 = Bonus 折扣 + 历史常买**
  - 不是“从全站硬搜”，而是有明确的 **候选集合**：
    - 当前的折扣商品（性价比高、时效强）
    - 用户历史常买（稳定偏好）
  - 这两个源合在一起，既能省钱，又能贴合个人习惯，是一个很好的“选择空间”定义方式。

- **3. LLM 做“规划”和“校验”，不是做低级控制**
  - LLM 负责：
    - 读需求、读商品列表，输出“怎么买比较合理”（分桶清单）。
    - 看已有购物车 + 需求，判断“够不够 / 差什么 / 应该再加啥”。
  - 浏览器细节（滚动、找按钮、点按钮）全部由确定性代码负责。
  - 这样重写时可以很清晰地拆：**Planning（LLM） vs. Execution（Selenium）**。

- **4. 浏览器会话是“长生命周期资源”**
  - 登录只做一次，之后靠：
    - Chrome 用户数据目录 + cookies 持久化。
    - `SessionManager` 统一管理同一套浏览器和登录状态。
  - Scraper 和 Cart 都是这个会话上的“使用者”，而不是各自起一个浏览器。

- **5. 购物历史是“无声的偏好模型”**
  - 历史只是一个本地 JSON，但在逻辑上可以看成：
    - 用户长期偏好的简易 embedding。
    - 给 LLM 的一个“用户画像”输入。
  - 重写时可以把“历史 → 特征/偏好摘要”这一层做得更显式（或者交给 LLM做）。

- **6. Auto Mode = 把人从 loop 里拿掉**
  - 正常模式：人还在中间决策（比如看一下结果、确认再执行）。
  - 自动模式：把所有交互点变成“无提示默认同意”，然后最后用邮件把结果告诉用户。
  - 这一套自动化开关非常适合之后扩展到定时任务/服务器部署。

---

### 从“逻辑视角”看模块分工（抽象到概念层）

- **输入层**
  - 用户自然语言需求（CLI / 文本 / 浏览器扩展）

- **数据源层**
  - AH Bonus 当前打折商品
  - `eerder_gekocht` 历史商品
  - 本地购物历史（多次购物的完整记录）
  - 当前购物车状态

- **智能决策层（LLM 驱动）**
  - 把“需求 + 候选商品 + 历史”转成一个结构化“购物计划”（按桶分组）。
  - 把“当前购物车 + 需求 + 候选商品”转成“是否满足 + 还差什么 + 需要加的具体货”。

- **执行层（浏览器自动化）**
  - 页面导航、滚动、搜索商品。
  - 定位商品卡片 / 详情页，加购到购物车。
  - 最终状态可在浏览器 UI 中直接检查。

- **状态与记忆层**
  - 登录会话（浏览器 profile + cookies）。
  - 商品缓存（避免频繁爬同一批 Bonus）。
  - 历史购物记录（可选：给 LLM 或直接统计使用）。

---

### 如果重写整个 repo，可以沿着这条主线来设计

- **第一优先级：保留 /强化的概念**
  - **“需求 → 计划 → 执行 → 校验” 这条 pipeline**
  - “候选商品池” 的设计（Bonus + 历史）
  - LLM 的职责边界：只做高层规划和检查，不下场点按钮
  - 会话与历史这两种“长期状态”的管理方式

- **可以大幅重构甚至重写的部分**
  - 具体 Selenium 操作细节（选择器、等待策略等）
  - 文件拆分方式（可以重写成 service / domain 层更清晰的结构）
  - 配置与运行入口（换成更现代的 CLI / Web API 都可以）

---

### 一句话总结

**这是一个围绕“用户一句话购物需求”构建的 AH.nl 智能代理：用爬虫和浏览器自动化接管“逛超市和加购”，用 LLM 接管“理解需求和做决策”，中间再用会话与历史把“人”的习惯长期地粘在这套系统里。**